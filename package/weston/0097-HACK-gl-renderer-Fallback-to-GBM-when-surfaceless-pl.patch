From 3d12bdd578258d3c53dace89ec3b9484abfe9937 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Wed, 20 Dec 2023 09:24:31 +0800
Subject: [PATCH 97/98] HACK: gl-renderer: Fallback to GBM when surfaceless
 platform not supported

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libweston/renderer-gl/egl-glue.c             |  8 +++++
 libweston/renderer-gl/gl-renderer-internal.h |  3 ++
 libweston/renderer-gl/gl-renderer.c          | 37 ++++++++++++++++++--
 3 files changed, 45 insertions(+), 3 deletions(-)

diff --git a/libweston/renderer-gl/egl-glue.c b/libweston/renderer-gl/egl-glue.c
index f6d7c48..b89e1ca 100644
--- a/libweston/renderer-gl/egl-glue.c
+++ b/libweston/renderer-gl/egl-glue.c
@@ -604,6 +604,14 @@ gl_renderer_setup_egl_client_extensions(struct gl_renderer *gr)
 	if (weston_check_egl_extension(extensions, s))
 		return 0;
 
+	/* HACK: Fallback to GBM platform */
+	if (gr->platform == EGL_PLATFORM_SURFACELESS_MESA) {
+		gr->platform = EGL_PLATFORM_GBM_KHR;
+		weston_log("Warn: EGL does not support %s platform, try GBM\n",
+			   extension_suffix);
+		return gl_renderer_setup_egl_client_extensions(gr);
+	}
+
 	/* at this point we definitely have some platform extensions but
 	 * haven't found the supplied platform, so chances are it's
 	 * not supported. */
diff --git a/libweston/renderer-gl/gl-renderer-internal.h b/libweston/renderer-gl/gl-renderer-internal.h
index bb14946..1eed407 100644
--- a/libweston/renderer-gl/gl-renderer-internal.h
+++ b/libweston/renderer-gl/gl-renderer-internal.h
@@ -33,6 +33,7 @@
 #include <time.h>
 
 #include <wayland-util.h>
+#include <gbm.h>
 #include <GLES2/gl2.h>
 #include <GLES2/gl2ext.h>
 #include "shared/weston-egl-ext.h"  /* for PFN* stuff */
@@ -240,6 +241,8 @@ struct gl_renderer {
 	struct weston_log_scope *shader_scope;
 
 	bool is_mali_egl;
+
+	struct gbm_device *gbm;
 };
 
 static inline struct gl_renderer *
diff --git a/libweston/renderer-gl/gl-renderer.c b/libweston/renderer-gl/gl-renderer.c
index 82fc33d..2d91385 100644
--- a/libweston/renderer-gl/gl-renderer.c
+++ b/libweston/renderer-gl/gl-renderer.c
@@ -31,6 +31,7 @@
 #include <GLES2/gl2ext.h>
 #include <GLES3/gl3.h>
 
+#include <fcntl.h>
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdlib.h>
@@ -42,6 +43,8 @@
 #include <linux/input.h>
 #include <unistd.h>
 
+#include <xf86drm.h>
+
 #include "linux-sync-file.h"
 #include "timeline.h"
 
@@ -4001,6 +4004,9 @@ gl_renderer_destroy(struct weston_compositor *ec)
 	if (gr->fan_binding)
 		weston_binding_destroy(gr->fan_binding);
 
+	if (gr->gbm)
+		gbm_device_destroy(gr->gbm);
+
 	weston_log_scope_destroy(gr->shader_scope);
 	weston_log_scope_destroy(gr->renderer_scope);
 	free(gr);
@@ -4044,6 +4050,8 @@ gl_renderer_display_create(struct weston_compositor *ec,
 			   const struct gl_renderer_display_options *options)
 {
 	struct gl_renderer *gr;
+	EGLint egl_surface_type = options->egl_surface_type;
+	void *egl_native_display = options->egl_native_display;
 	int ret;
 
 	gr = zalloc(sizeof *gr);
@@ -4066,6 +4074,28 @@ gl_renderer_display_create(struct weston_compositor *ec,
 	if (gl_renderer_setup_egl_client_extensions(gr) < 0)
 		goto fail;
 
+	/* HACK: Fixup options for GBM platform */
+	if (gr->platform == EGL_PLATFORM_GBM_KHR) {
+		if (!egl_surface_type)
+			egl_surface_type = EGL_WINDOW_BIT;
+
+		if (!egl_native_display) {
+			int drm_fd = drmOpen("rockchip", NULL);
+			if (drm_fd < 0)
+				drm_fd = open("/dev/dri/card0",
+					      O_RDWR | O_CLOEXEC);
+			if (drm_fd < 0)
+				goto fail;
+
+			gr->gbm = gbm_create_device(drm_fd);
+			close(drm_fd);
+			if (!gr->gbm)
+				goto fail;
+
+			egl_native_display = gr->gbm;
+		}
+	}
+
 	gr->base.read_pixels = gl_renderer_read_pixels;
 	gr->base.repaint_output = gl_renderer_repaint_output;
 	gr->base.resize_output = gl_renderer_resize_output;
@@ -4076,7 +4106,7 @@ gl_renderer_display_create(struct weston_compositor *ec,
 	gr->base.fill_buffer_info = gl_renderer_fill_buffer_info;
 	gr->base.type = WESTON_RENDERER_GL;
 
-	if (gl_renderer_setup_egl_display(gr, options->egl_native_display) < 0)
+	if (gl_renderer_setup_egl_display(gr, egl_native_display) < 0)
 		goto fail;
 
 	weston_drm_format_array_init(&gr->supported_formats);
@@ -4092,8 +4122,6 @@ gl_renderer_display_create(struct weston_compositor *ec,
 		goto fail_terminate;
 
 	if (!gr->has_configless_context) {
-		EGLint egl_surface_type = options->egl_surface_type;
-
 		if (!gr->has_surfaceless_context)
 			egl_surface_type |= EGL_PBUFFER_BIT;
 
@@ -4190,6 +4218,9 @@ fail_terminate:
 	weston_drm_format_array_fini(&gr->supported_formats);
 	eglTerminate(gr->egl_display);
 fail:
+	if (gr->gbm)
+		gbm_device_destroy(gr->gbm);
+
 	weston_log_scope_destroy(gr->shader_scope);
 	weston_log_scope_destroy(gr->renderer_scope);
 	free(gr);
-- 
2.20.1

