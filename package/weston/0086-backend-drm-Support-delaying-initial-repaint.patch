From cd15a12813102f28398ba2a8e8971b1436812276 Mon Sep 17 00:00:00 2001
From: Jeffy Chen <jeffy.chen@rock-chips.com>
Date: Thu, 19 Oct 2023 11:41:06 +0800
Subject: [PATCH 86/98] backend-drm: Support delaying initial repaint

Set env "WESTON_DRM_INITIAL_FREEZE_MS" for the initial freezing.

Signed-off-by: Jeffy Chen <jeffy.chen@rock-chips.com>
---
 libweston/backend-drm/drm-internal.h |  3 +++
 libweston/backend-drm/drm.c          | 25 +++++++++++++++++++++++++
 2 files changed, 28 insertions(+)

diff --git a/libweston/backend-drm/drm-internal.h b/libweston/backend-drm/drm-internal.h
index 7e8612481f..bf8f7761a2 100644
--- a/libweston/backend-drm/drm-internal.h
+++ b/libweston/backend-drm/drm-internal.h
@@ -405,6 +405,9 @@ struct drm_backend {
 	int64_t last_update_ms;
 	int64_t resize_freeze_ms;
 
+	int64_t initial_update_ms;
+	int64_t initial_freeze_ms;
+
 	bool master;
 	bool single_head;
 	bool head_fallback;
diff --git a/libweston/backend-drm/drm.c b/libweston/backend-drm/drm.c
index b13524ba23..1b7e48ba8b 100644
--- a/libweston/backend-drm/drm.c
+++ b/libweston/backend-drm/drm.c
@@ -1020,18 +1020,25 @@ drm_output_repaint(struct weston_output *output_base, pixman_region32_t *damage)
 	struct drm_plane_state *cursor_state;
 	struct drm_pending_state *pending_state;
 	struct drm_device *device;
+	struct drm_backend *b;
+	struct timespec now;
+	int64_t now_ms;
 
 	assert(output);
 	assert(!output->virtual);
 
 	device = output->device;
 	pending_state = device->repaint_data;
+	b = device->backend;
 
 	if (output->disable_pending || output->destroy_pending)
 		goto err;
 
 	assert(!output->state_last);
 
+	weston_compositor_read_presentation_clock(b->compositor, &now);
+	now_ms = timespec_to_msec(&now);
+
 	if (output->freezing) {
 		int64_t refresh_nsec =
 			millihz_to_nsec(output_base->current_mode->refresh);
@@ -1040,6 +1047,14 @@ drm_output_repaint(struct weston_output *output_base, pixman_region32_t *damage)
 		return 1;
 	}
 
+	if (now_ms < b->initial_update_ms + b->initial_freeze_ms) {
+		int64_t duration =
+			b->initial_update_ms + b->initial_freeze_ms - now_ms;
+		timespec_add_msec(&output_base->next_repaint,
+				  &output_base->next_repaint, duration);
+		return 1;
+	}
+
 	/* If planes have been disabled in the core, we might not have
 	 * hit assign_planes at all, so might not have valid output state
 	 * here. */
@@ -3568,6 +3583,12 @@ drm_backend_update_connectors(struct drm_device *device,
 	uint32_t connector_id;
 	int i, ret;
 
+	if (!b->primary_head) {
+		struct timespec now;
+		weston_compositor_read_presentation_clock(b->compositor, &now);
+		b->initial_update_ms = timespec_to_msec(&now);
+	}
+
 	resources = drmModeGetResources(device->drm.fd);
 	if (!resources) {
 		weston_log("drmModeGetResources failed\n");
@@ -4927,6 +4948,10 @@ drm_backend_create(struct weston_compositor *compositor,
 		weston_log("Entering mirror mode.\n");
 	}
 
+	buf = getenv("WESTON_DRM_INITIAL_FREEZE_MS");
+	if (buf)
+		b->initial_freeze_ms = atoi(buf);
+
 	device = zalloc(sizeof *device);
 	if (device == NULL)
 		return NULL;
-- 
2.20.1

