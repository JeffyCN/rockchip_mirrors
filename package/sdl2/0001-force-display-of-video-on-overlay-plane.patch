From 7c012cf4f006c3a1712ef3908c8ba5f18f5da5b5 Mon Sep 17 00:00:00 2001
From: Hertz Wang <wangh@rock-chips.com>
Date: Fri, 16 Nov 2018 17:03:43 +0800
Subject: [PATCH] force display of video on overlay plane

note: control the video display layer according
      to the SDL2_DISPLAY_PLANE_TYPE environment variable

Signed-off-by: Hertz Wang <wangh@rock-chips.com>
---
 src/video/kmsdrm/SDL_kmsdrmopengles.c | 11 ++++
 src/video/kmsdrm/SDL_kmsdrmsym.h      | 16 ++++++
 src/video/kmsdrm/SDL_kmsdrmvideo.c    | 72 +++++++++++++++++++++++++++
 src/video/kmsdrm/SDL_kmsdrmvideo.h    |  4 ++
 4 files changed, 103 insertions(+)

diff --git a/src/video/kmsdrm/SDL_kmsdrmopengles.c b/src/video/kmsdrm/SDL_kmsdrmopengles.c
index 25d942e..e2e4819 100644
--- a/src/video/kmsdrm/SDL_kmsdrmopengles.c
+++ b/src/video/kmsdrm/SDL_kmsdrmopengles.c
@@ -141,6 +141,17 @@ KMSDRM_GLES_SwapWindow(_THIS, SDL_Window * window) {
         return 0;
     }
 
+    if (windata->plane_id) {
+        ret = KMSDRM_drmModeSetPlane(viddata->drm_fd,
+          windata->plane_id, dispdata->crtc->crtc_id, fb_info->fb_id,
+          0, 0, 0, dispdata->mode.hdisplay, dispdata->mode.vdisplay,
+          0, 0, KMSDRM_gbm_bo_get_width(windata->next_bo) << 16,
+          KMSDRM_gbm_bo_get_height(windata->next_bo) << 16);
+        if(ret != 0) {
+            SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Could not set plane: %d", ret);
+            return 0;
+        }
+    } else
     if (!windata->bo) {
         /* On the first swap, immediately present the new front buffer. Before
            drmModePageFlip can be used the CRTC has to be configured to use
diff --git a/src/video/kmsdrm/SDL_kmsdrmsym.h b/src/video/kmsdrm/SDL_kmsdrmsym.h
index 52c78de..5cbf338 100644
--- a/src/video/kmsdrm/SDL_kmsdrmsym.h
+++ b/src/video/kmsdrm/SDL_kmsdrmsym.h
@@ -40,10 +40,15 @@ SDL_KMSDRM_SYM(void,drmModeFreeFB,(drmModeFBPtr ptr))
 SDL_KMSDRM_SYM(void,drmModeFreeCrtc,(drmModeCrtcPtr ptr))
 SDL_KMSDRM_SYM(void,drmModeFreeConnector,(drmModeConnectorPtr ptr))
 SDL_KMSDRM_SYM(void,drmModeFreeEncoder,(drmModeEncoderPtr ptr))
+SDL_KMSDRM_SYM(void,drmModeFreePlane,(drmModePlanePtr ptr))
+SDL_KMSDRM_SYM(void,drmModeFreePlaneResources,(drmModePlaneResPtr ptr))
+SDL_KMSDRM_SYM(void,drmModeFreeProperty,(drmModePropertyPtr ptr))
+SDL_KMSDRM_SYM(void,drmModeFreeObjectProperties,(drmModeObjectPropertiesPtr ptr))
 SDL_KMSDRM_SYM(int,drmGetCap,(int fd, uint64_t capability, uint64_t *value))
 SDL_KMSDRM_SYM(int,drmSetMaster,(int fd))
 SDL_KMSDRM_SYM(int,drmAuthMagic,(int fd, drm_magic_t magic))
 SDL_KMSDRM_SYM(drmModeResPtr,drmModeGetResources,(int fd))
+SDL_KMSDRM_SYM(drmModePlaneResPtr,drmModeGetPlaneResources,(int fd))
 SDL_KMSDRM_SYM(int,drmModeAddFB,(int fd, uint32_t width, uint32_t height, uint8_t depth,
                          uint8_t bpp, uint32_t pitch, uint32_t bo_handle,
                          uint32_t *buf_id))
@@ -56,6 +61,10 @@ SDL_KMSDRM_SYM(int,drmModeAddFB2,(int fd, uint32_t width, uint32_t height,
 SDL_KMSDRM_SYM(int,drmModeRmFB,(int fd, uint32_t bufferId))
 SDL_KMSDRM_SYM(drmModeFBPtr,drmModeGetFB,(int fd, uint32_t buf))
 SDL_KMSDRM_SYM(drmModeCrtcPtr,drmModeGetCrtc,(int fd, uint32_t crtcId))
+SDL_KMSDRM_SYM(drmModePlanePtr,drmModeGetPlane,(int fd, uint32_t plane_id))
+SDL_KMSDRM_SYM(drmModePropertyPtr,drmModeGetProperty,(int fd, uint32_t propertyId))
+SDL_KMSDRM_SYM(drmModeObjectPropertiesPtr,drmModeObjectGetProperties,
+               (int fd, uint32_t object_id, uint32_t object_type))
 SDL_KMSDRM_SYM(int,drmModeSetCrtc,(int fd, uint32_t crtcId, uint32_t bufferId,
                                    uint32_t x, uint32_t y, uint32_t *connectors, int count,
                                    drmModeModeInfoPtr mode))
@@ -68,12 +77,19 @@ SDL_KMSDRM_SYM(int,drmModeSetCursor,(int fd, uint32_t crtcId, uint32_t bo_handle
 SDL_KMSDRM_SYM(int,drmModeSetCursor2,(int fd, uint32_t crtcId, uint32_t bo_handle,
                                       uint32_t width, uint32_t height,
                                       int32_t hot_x, int32_t hot_y))
+SDL_KMSDRM_SYM(int,drmModeSetPlane,(int fd, uint32_t plane_id, uint32_t crtc_id,
+                                    uint32_t fb_id, uint32_t flags,
+                                    int32_t crtc_x, int32_t crtc_y,
+                                    uint32_t crtc_w, uint32_t crtc_h,
+                                    uint32_t src_x, uint32_t src_y,
+                                    uint32_t src_w, uint32_t src_h))
 SDL_KMSDRM_SYM(int,drmModeMoveCursor,(int fd, uint32_t crtcId, int x, int y))
 SDL_KMSDRM_SYM(drmModeEncoderPtr,drmModeGetEncoder,(int fd, uint32_t encoder_id))
 SDL_KMSDRM_SYM(drmModeConnectorPtr,drmModeGetConnector,(int fd, uint32_t connector_id))
 SDL_KMSDRM_SYM(int,drmHandleEvent,(int fd,drmEventContextPtr evctx))
 SDL_KMSDRM_SYM(int,drmModePageFlip,(int fd, uint32_t crtc_id, uint32_t fb_id,
                                     uint32_t flags, void *user_data))
+SDL_KMSDRM_SYM(int,drmSetClientCap,(int fd, uint64_t capability, uint64_t value))
 
 /* Planes stuff. */
 SDL_KMSDRM_SYM(int,drmSetClientCap,(int fd, uint64_t capability, uint64_t value))
diff --git a/src/video/kmsdrm/SDL_kmsdrmvideo.c b/src/video/kmsdrm/SDL_kmsdrmvideo.c
index fd3a3cd..61df058 100644
--- a/src/video/kmsdrm/SDL_kmsdrmvideo.c
+++ b/src/video/kmsdrm/SDL_kmsdrmvideo.c
@@ -540,6 +540,7 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources) {
     SDL_VideoDisplay display = {0};
     SDL_DisplayModeData *modedata = NULL;
     drmModeEncoder *encoder = NULL;
+    drmModePlaneRes *plane_res = NULL;
     drmModeCrtc *crtc = NULL;
     int mode_index;
     int i, j;
@@ -667,6 +668,56 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources) {
         goto cleanup;
     }
 
+    plane_res = KMSDRM_drmModeGetPlaneResources(viddata->drm_fd);
+    if (!plane_res) {
+        ret = SDL_SetError("Couldn't get plane res");
+        goto cleanup;
+    }
+    for (i = 0; i < plane_res->count_planes; i++) {
+        int j;
+        drmModeObjectPropertiesPtr props;
+        uint32_t plane_id = plane_res->planes[i];
+        drmModePlane *plane = KMSDRM_drmModeGetPlane(viddata->drm_fd, plane_id);
+        if (!plane) {
+        	ret = SDL_SetError("Couldn't get plane");
+            goto cleanup;
+        }
+        props = KMSDRM_drmModeObjectGetProperties(viddata->drm_fd, plane_id, DRM_MODE_OBJECT_PLANE);
+        if (!props) {
+            ret = SDL_SetError("Couldn't get plane properties");
+            KMSDRM_drmModeFreePlane(plane);
+            goto cleanup;
+        }
+        for (j = 0; j < props->count_props; j++) {
+            int z;
+            drmModePropertyPtr p = KMSDRM_drmModeGetProperty(viddata->drm_fd, props->props[j]);
+            uint64_t value = props->prop_values[j];
+
+            if (!p) {
+                SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Couldn't get property\n");
+                continue;
+            }
+            if (strcmp(p->name, "type"))
+                continue;
+            for (z = 0; z < p->count_enums; z++) {
+                int n;
+                static const char* names[3] = { "Overlay", "Primary", "Cursor" };
+                if (p->enums[z].value != value)
+                    continue;
+                for (n = 0; n < 3; n++) {
+                    if (!strcmp(p->enums[z].name, names[n])) {
+                        data->plane_ids[n] = plane_id;
+                        SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "%s : %d\n", names[n], plane_id);
+                        break;
+                    }
+                }
+            }
+            KMSDRM_drmModeFreeProperty(p);
+        }
+        KMSDRM_drmModeFreeObjectProperties(props);
+    }
+
+
     /* Store the connector and crtc for this display. */
     dispdata->connector = connector;
     dispdata->crtc = crtc;
@@ -700,6 +751,8 @@ KMSDRM_AddDisplay (_THIS, drmModeConnector *connector, drmModeRes *resources) {
 cleanup:
     if (encoder)
         KMSDRM_drmModeFreeEncoder(encoder);
+    if (plane_res != NULL)
+        KMSDRM_drmModeFreePlaneResources(plane_res);
     if (ret) {
         /* Error (complete) cleanup */
         if (dispdata) {
@@ -745,6 +798,9 @@ KMSDRM_InitDisplays (_THIS) {
 
     SDL_LogDebug(SDL_LOG_CATEGORY_VIDEO, "Opened DRM FD (%d)", viddata->drm_fd);
 
+    KMSDRM_drmSetClientCap(viddata->drm_fd, DRM_CLIENT_CAP_UNIVERSAL_PLANES, 1);
+    KMSDRM_drmSetClientCap(viddata->drm_fd, DRM_CLIENT_CAP_ATOMIC, 1);
+
     /* Get all of the available connectors / devices / crtcs */
     resources = KMSDRM_drmModeGetResources(viddata->drm_fd);
     if (!resources) {
@@ -1247,6 +1303,7 @@ KMSDRM_CreateWindow(_THIS, SDL_Window * window)
     SDL_bool vulkan_mode = viddata->vulkan_mode; /* Do we have any Vulkan windows? */
     NativeDisplayType egl_display;
     drmModeModeInfo *mode;
+    char *display_plane_type = NULL;
     int ret = 0;
 
     /* Allocate window internal data */
@@ -1255,6 +1312,21 @@ KMSDRM_CreateWindow(_THIS, SDL_Window * window)
         return(SDL_OutOfMemory());
     }
 
+    display_plane_type = getenv("SDL2_DISPLAY_PLANE_TYPE");
+
+    if (!display_plane_type)
+        windata->plane_id = 0;
+    else {
+        if (!strcmp(display_plane_type, "OVERLAY"))
+            windata->plane_id = ((SDL_DisplayData *)display->driverdata)->plane_ids[0];
+        else if (!strcmp(display_plane_type, "PRIMARY"))
+            windata->plane_id = ((SDL_DisplayData *)display->driverdata)->plane_ids[1];
+        else if (!strcmp(display_plane_type, "CURSOR"))
+            windata->plane_id = ((SDL_DisplayData *)display->driverdata)->plane_ids[2];
+        else
+            windata->plane_id = 0;
+    }
+
     /* Setup driver data for this window */
     windata->viddata = viddata;
     window->driverdata = windata;
diff --git a/src/video/kmsdrm/SDL_kmsdrmvideo.h b/src/video/kmsdrm/SDL_kmsdrmvideo.h
index ebc863f..270d2c5 100644
--- a/src/video/kmsdrm/SDL_kmsdrmvideo.h
+++ b/src/video/kmsdrm/SDL_kmsdrmvideo.h
@@ -81,6 +81,8 @@ typedef struct SDL_DisplayData
     uint64_t cursor_w, cursor_h;
 
     SDL_bool default_cursor_init;
+
+    uint32_t plane_ids[3];  /* Overlay, Primary, Cursor */
 } SDL_DisplayData;
 
 typedef struct SDL_WindowData
@@ -99,6 +101,8 @@ typedef struct SDL_WindowData
 
     EGLSurface egl_surface;
     SDL_bool egl_surface_dirty;
+
+    uint32_t plane_id;
 } SDL_WindowData;
 
 typedef struct KMSDRM_FBInfo
-- 
2.20.1

